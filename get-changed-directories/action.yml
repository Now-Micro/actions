name: 'Get Changed Project Directories'
description: 'Detects changed .NET project directories and returns them as a JSON array'
author: 'Trafera'

inputs:
  directories:
    description: 'Comma-separated list of directories to check for a project file (e.g. "tests,examples"). "src" is automatically included.'
    required: false
  head-ref:
    description: 'The head branch of the pull request'
    required: false
    default: ${{ github.head_ref }}
  base-ref:
    description: 'The base branch of the pull request'
    required: false
    default: ${{ github.base_ref }}
  max-depth:
    description: 'Maximum depth to search for project files'
    required: false
    default: '3'
  pattern-to-match:
    description: 'Pattern to match source directories'
    required: false
    default: '^([^/]*)\/.*'  # Matches everything before the first forward slash
  project-file-extension:
    description: 'Project file extension to look for'
    required: false
    default: '.csproj'

outputs:
  changed_project_directories:
    description: 'JSON array of changed project directories'
    value: ${{ steps.parse-changes.outputs.changed_project_directories }}
  changed_solution_directories:
    description: 'JSON array of changed solution directories'
    value: ${{ steps.parse-changes.outputs.changed_solution_directories }}
  has_changes:
    description: 'Boolean indicating if any directories have changes'
    value: ${{ steps.parse-changes.outputs.has_changes }}
  changed_count:
    description: 'Number of changed directories'
    value: ${{ steps.parse-changes.outputs.changed_count }}

runs:
  using: 'composite'
  steps:
    - name: Setup Node.js
      uses: ./.github/actions/setup-node

    - name: Determine changed project directories
      id: parse-changes
      shell: bash
      run: |
        cat > detect-changes.js << 'EOF'
        const { execSync } = require('child_process');
        const fs = require('fs');
        const path = require('path');

        console.log('üîç Detecting Changed Project Directories');
        console.log('========================================');
        console.log('Head branch:', process.env.INPUT_HEAD_REF);
        console.log('Base branch:', process.env.INPUT_BASE_REF);
        console.log('Source pattern:', process.env.INPUT_PATTERN_TO_MATCH);
        console.log('Project extension:', process.env.INPUT_PROJECT_FILE_EXTENSION);
        console.log('Directories to scan for projects:', process.env.INPUT_DIRECTORIES);

        try {
          // Use explicit SHAs if provided, fallback to branch names
          const baseSha = process.env.INPUT_BASE_REF || '';
          const headSha = process.env.INPUT_HEAD_REF || '';
          const prNumber = process.env.GITHUB_PR_NUMBER || '';
          function ensureCommitExists(sha, prNumber) {
            try {
              execSync(`git cat-file -e ${sha}^{commit}`);
              return true;
            } catch {
              // Try to fetch the PR ref if prNumber is provided
              if (prNumber) {
                try {
                  execSync(`git fetch origin pull/${prNumber}/head:pr-${prNumber}`);
                  execSync(`git cat-file -e ${sha}^{commit}`);
                  return true;
                } catch {
                  // Continue to try fetching from origin by SHA/branch
                }
              }
              // Try to fetch from origin by branch/sha
              try {
                execSync(`git fetch origin ${sha}`);
                execSync(`git cat-file -e ${sha}^{commit}`);
                return true;
              } catch {
                return false;
              }
            }
          }
          if (baseSha && !ensureCommitExists(baseSha, prNumber)) {
            throw new Error(`Base SHA ${baseSha} not found and could not be fetched.`);
          }
          if (headSha && !ensureCommitExists(headSha, prNumber)) {
            throw new Error(`Head SHA ${headSha} not found and could not be fetched.`);
          }
          let gitCommand;
          if (baseSha && headSha) {
            gitCommand = `git diff --name-only ${baseSha}...${headSha}`;
          } else if (baseSha) {
            gitCommand = `git diff --name-only ${baseSha}...HEAD`;
          } else {
            gitCommand = 'git diff --name-only';
          }
          console.log('Git command:', gitCommand);
          const files = execSync(gitCommand, {
            encoding: 'utf8'
          }).trim();

          console.log('\n=== Changed Files ===');
          if (files) {
            console.log(files);
          } else {
            console.log('(no files changed)');
          }
          console.log('====================\n');

          if (!files) {
            console.log('No changed files found.');
            const output = {
              changed_project_directories: '[]',
              changed_solution_directories: '[]',
              has_changes: 'false',
              changed_count: '0'
            };
            
            Object.entries(output).forEach(([key, value]) => {
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${key}=${value}\n`);
            });
            
            console.log('‚úÖ Complete - no changes detected');
            process.exit(0);
          }

          // Find all changed files under any src/* subdir
          const fileList = files.split('\n').filter(f => f.trim());
          const patternToMatch = new RegExp(process.env.INPUT_PATTERN_TO_MATCH);
          const directoriesToSearch = new Set();

          fileList.forEach(file => {
            const match = patternToMatch ? file.match(patternToMatch) : true;
            if (match) {
              const matchRoot = file.match(/^([^/]*)\/.*/);
              for (const dir of (process.env.INPUT_DIRECTORIES ? process.env.INPUT_DIRECTORIES.split(',').map(d => d.trim()) : [])) {
                if (dir) {
                  const additionalDir = `${matchRoot[1]}/${dir}`;
                  directoriesToSearch.add(additionalDir);
                }
              }

              const projectSourceDir = `${matchRoot[1]}/src`;
              directoriesToSearch.add(projectSourceDir);
            }
          });

          console.log(`\nüìä ${directoriesToSearch.size} directories to search`);

          // Function to recursively search for project files
          function findProjectFile(directory, extension, maxDepth = parseInt(${{ inputs.max-depth }}, 10), currentDepth = 0) {
            if (currentDepth > maxDepth) return null;
            
            try {
              const entries = fs.readdirSync(directory, { withFileTypes: true });
              
              // First check for project files in current directory
              for (const entry of entries) {
                if (entry.isFile() && entry.name.endsWith(extension)) {
                  return directory;
                }
              }
              
              // Then recursively check subdirectories
              for (const entry of entries) {
                if (entry.isDirectory()) {
                  const subdirectoryPath = path.join(directory, entry.name);
                  const result = findProjectFile(subdirectoryPath, extension, maxDepth, currentDepth + 1);
                  if (result) {
                    return result;
                  }
                }
              }
              
              return null;
            } catch (error) {
              return null;
            }
          }
          
          // Filter directories that contain project files
          const filteredDirs = [];
          const projectExtension = process.env.INPUT_PROJECT_FILE_EXTENSION;
          
          for (const dir of directoriesToSearch) {
            const projectDirectory = findProjectFile(dir, projectExtension);

            if (projectDirectory) {
              filteredDirs.push(projectDirectory);
              console.log(`  ‚úÖ ${dir} - contains ${projectExtension} files (directly or in subdirectories)`);
            } else {
              console.log(`  ‚ùå ${dir} - no ${projectExtension} files found in directory tree`);
            }
          }

          // Assuming that the solution directories are at the root
          const solutionDirs = Array.from(filteredDirs).map(dir => {
            const match = dir.match(/^([^/]*)\/.*/);
            if (match) {
              return match[1];
            }
            return null;
          }).filter(Boolean);

          // Create outputs
          const json = JSON.stringify(filteredDirs);
          const solutionJSON = JSON.stringify(Array.from(new Set(solutionDirs.map(dir => dir.trim()))));
          const hasChanges = filteredDirs.length > 0 ? 'true' : 'false';
          const changeCount = filteredDirs.length.toString();

          console.log(`\nüì§ Outputs:`);
          console.log(`  changed_project_directories: ${json}`);
          console.log(`  changed_solution_directories: ${solutionJSON}`);
          console.log(`  has_changes: ${hasChanges}`);
          console.log(`  changed_count: ${changeCount}`);

          // Validate JSON
          try {
            JSON.parse(solutionJSON);
            JSON.parse(json);
            console.log('‚úÖ JSON validation passed');
          } catch (error) {
            console.error('‚ùå JSON validation failed:', error);
            process.exit(1);
          }

          // Write to GITHUB_OUTPUT
          const outputs = {
            changed_project_directories: json,
            changed_solution_directories: solutionJSON,
            has_changes: hasChanges,
            changed_count: changeCount
          };

          Object.entries(outputs).forEach(([key, value]) => {
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `${key}=${value}\n`);
          });

          console.log('‚úÖ Complete - outputs written successfully');

        } catch (error) {
          console.error('‚ùå Error:', error.message);
          process.exit(1);
        }
        EOF

        node detect-changes.js
      env:
        INPUT_HEAD_REF: ${{ inputs.head-ref }}
        INPUT_BASE_REF: ${{ inputs.base-ref }}
        INPUT_DIRECTORIES: ${{ inputs.directories }}
        INPUT_PATTERN_TO_MATCH: ${{ inputs.pattern-to-match }}
        INPUT_PROJECT_FILE_EXTENSION: ${{ inputs.project-file-extension }}
