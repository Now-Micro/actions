name: Release - Deploy Nuget Packages

on:
  push:
    branches: [release/**]
  pull_request:
    branches: [release/**]
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      package:
        description: "Package name to release"
        required: true
        type: choice
        options:
          - ImageRepository
          - SnmpUtilities
          - Trafera.Aspire.ServiceDefaults
          - Trafera.ChannelOnline
          - Trafera.CSI
          - Trafera.DataTransformer
          - Trafera.Document
          - Trafera.HubSpot
          - Trafera.HybridCache
          - Trafera.MassTransit
          - Trafera.MediatR
          - Trafera.Observability
          - Trafera.TestingDataConstants
          - Trafera.Warranty.Mapper
      version:
        description: "Version to package"
        required: true

env:
  NUGET_PACKAGE_DIR: "nupkgs"

jobs:
  validate-release:
    if: (github.event_name == 'workflow_dispatch' && github.ref_name == 'main') || github.event_name != 'workflow_dispatch'
    runs-on: ubuntu-22.04
    outputs:
      changed_dirs: ${{ steps.parse-changes.outputs.changed_dirs }}
      release_version: ${{ steps.get-version.outputs.version }}
      library_name: ${{ steps.get-version.outputs.library_name }}
    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse release configuration
        id: get-version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual workflow dispatch - use inputs
            LIBRARY_NAME="${{ github.event.inputs.package }}"
            VERSION="${{ github.event.inputs.version }}"
            
            echo "Manual workflow dispatch detected:"
            echo "  Library: $LIBRARY_NAME"
            echo "  Version: $VERSION"
            
            # Validate semantic version format for manual input
            if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
              echo "ERROR: Invalid semantic version format: $VERSION"
              echo "Expected format: X.Y.Z or X.Y.Z-prerelease"
              exit 1
            fi
            
          else
            # Release branch push - parse from branch name
            BRANCH_NAME="${{ github.ref_name }}"
            
            # Only support library-specific releases: release/LibraryName/X.Y.Z
            if [[ "$BRANCH_NAME" =~ ^release/([^/]+)/([0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?)$ ]]; then
              LIBRARY_NAME="${BASH_REMATCH[1]}"
              VERSION="${BASH_REMATCH[2]}"
              
              echo "Library-specific release detected:"
              echo "  Library: $LIBRARY_NAME"
              echo "  Version: $VERSION"
              
            else
              echo "ERROR: Invalid release branch name: $BRANCH_NAME"
              echo "Expected format: release/LibraryName/X.Y.Z"
              echo "Examples:"
              echo "  - release/Trafera.MediatR/1.2.0"
              echo "  - release/Trafera.HubSpot/2.1.3"
              echo "  - release/DataTransformer/1.0.0-beta.1"
              exit 1
            fi
            
            # Validate semantic version format
            if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
              echo "ERROR: Invalid semantic version format: $VERSION"
              echo "Expected format: X.Y.Z or X.Y.Z-prerelease"
              exit 1
            fi
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "library_name=$LIBRARY_NAME" >> $GITHUB_OUTPUT
          echo "Release configuration validated successfully."

      - name: Determine target directory for release
        id: parse-changes
        run: |
          LIBRARY_NAME="${{ steps.get-version.outputs.library_name }}"

          echo "Library-specific release mode: targeting $LIBRARY_NAME"

          # Find the specific library directory
          LIBRARY_DIR=""
          for potential_dir in */src/*; do
            if [[ -d "$potential_dir" ]]; then
              # Check if directory contains .csproj files using find
              if find "$potential_dir" -maxdepth 1 -name "*.csproj" -print -quit | grep -q .; then
                PROJECT_NAME=$(find "$potential_dir" -maxdepth 1 -name "*.csproj" -exec basename {} .csproj \; | head -1)
                if [[ "$PROJECT_NAME" == "$LIBRARY_NAME" ]]; then
                  LIBRARY_DIR="$potential_dir"
                  break
                fi
              fi
            fi
          done

          if [ -z "$LIBRARY_DIR" ]; then
            echo "ERROR: Could not find library directory for '$LIBRARY_NAME'"
            echo "Available libraries:"
            for dir in */src/*; do
              if [[ -d "$dir" ]]; then
                # Check if directory contains .csproj files using find
                if find "$dir" -maxdepth 1 -name "*.csproj" -print -quit | grep -q .; then
                  PROJECT_NAME=$(find "$dir" -maxdepth 1 -name "*.csproj" -exec basename {} .csproj \; | head -1)
                  echo "  - $PROJECT_NAME (in $dir)"
                fi
              fi
            done
            exit 1
          fi

          echo "Found target library at: $LIBRARY_DIR"
          JSON="[\"$LIBRARY_DIR\"]"

          echo "DEBUG: Target directory JSON:"
          echo "$JSON"

          # Validate JSON
          JSON=$(echo "$JSON" | jq -c .)
          if echo "$JSON" | jq empty; then
            echo "DEBUG: JSON validated successfully."
          else
            echo "ERROR: JSON validation failed!"
            exit 1
          fi

          echo "changed_dirs=$JSON" >> $GITHUB_OUTPUT

  publish:
    runs-on: ubuntu-22.04
    needs: [validate-release]
    if: ${{ needs.validate-release.outputs.changed_dirs != '[]' }}
    strategy:
      fail-fast: true # Fail fast for releases
      matrix:
        directory: ${{ fromJson(needs.validate-release.outputs.changed_dirs) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get Root Directory
        id: get-root-dir
        uses: Now-Micro/actions/string-manipulator@v1
        with:
          match-output-is-json: "false"
          string: ${{ matrix.directory }}
          regex: ${{ vars.RELEASE_GET_ROOT_DIRECTORY_REGEX }}
          debug-mode: ${{ vars.CI_DEBUG_MODE }}

      - name: Get Project File (Main)
        id: extract-project-main
        uses: Now-Micro/actions/get-project-and-solution-files-from-directory@v1
        with:
          directory: ${{ matrix.directory }}
          debug-mode: ${{ vars.CI_DEBUG_MODE }}
          find-project: true
          find-solution: false
          project-regex: ${{ vars.NUGET_PROJECT_REGEX }}

      - name: Get Project File (Test)
        id: extract-project-test
        uses: Now-Micro/actions/get-project-and-solution-files-from-directory@v1
        with:
          directory: ${{ steps.get-root-dir.outputs.matches }}
          debug-mode: ${{ vars.CI_DEBUG_MODE }}
          find-project: true
          find-solution: false
          project-regex: ${{ vars.TEST_PROJECT_REGEX }}

      - name: Nuget Publish
        uses: Now-Micro/actions/nuget/publish@v1
        with:
          additional-build-args: --property WarningLevel=0 /p:Version=${{ needs.validate-release.outputs.release_version }}
          additional-pack-args: /p:PackageVersion=${{ needs.validate-release.outputs.release_version }} -p:IncludeSymbols=true -p:SymbolPackageFormat=snupkg
          dotnet-version: ${{ vars.RELEASE_DOTNET_VERSION }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          nuget-names: "github"
          nuget-passwords: ${{ secrets.TOKEN_GITHUB_PACKAGES }}
          nuget-urls: "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json"
          nuget-usernames: ${{ github.actor }}
          project-file: ${{ steps.extract-project-main.outputs.project-found }}
          package-directory: ${{ matrix.directory }}/${{ env.NUGET_PACKAGE_DIR }}
          test-project-file: ${{ steps.extract-project-test.outputs.project-found }}

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.validate-release.outputs.library_name }}-${{ needs.validate-release.outputs.release_version }}
          path: |
            ${{ matrix.directory }}/${{ env.NUGET_PACKAGE_DIR }}/*.nupkg
            ${{ matrix.directory }}/${{ env.NUGET_PACKAGE_DIR }}/*.snupkg
            ${{ matrix.directory }}/${{ env.NUGET_PACKAGE_DIR }}/*.symbols.nupkg
          retention-days: ${{ vars.NUGET_ARTIFACT_RETENTION_DAYS }}

      - name: Upload changelog artifact
        id: extract-changelog
        uses: Now-Micro/actions/extract-changelog@v1
        with:
          library-name: ${{ needs.validate-release.outputs.library_name }}
          version: ${{ needs.validate-release.outputs.release_version }}
          library-directory: ${{ matrix.directory }}
          create-artifact: "true"
          changelog-content-path: "changelog-content"

  create-github-release:
    runs-on: ubuntu-22.04
    needs: [validate-release, publish]
    if: needs.validate-release.outputs.changed_dirs != '[]'
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-artifacts

      - name: Prepare release assets
        id: prepare-assets
        run: |
          mkdir -p release-packages
          find release-artifacts -type f \( -name "*.nupkg" -o -name "*.snupkg" -o -name "*.symbols.nupkg" \) -exec cp {} release-packages/ \;

          echo "Release packages:"
          ls -la release-packages/

          LIBRARY_NAME="${{ needs.validate-release.outputs.library_name }}"
          VERSION="${{ needs.validate-release.outputs.release_version }}"

          # Create release notes for library-specific release
          cat > RELEASE_NOTES.md << EOF
          # $LIBRARY_NAME v$VERSION

          ## ðŸ“¦ Library Release
          This is a targeted release for **$LIBRARY_NAME** version **$VERSION**.

          ## ðŸ“¥ Installation
          \`\`\`bash
          dotnet add package $LIBRARY_NAME --version $VERSION
          \`\`\`

          ## ðŸ”§ Package Details
          EOF

          # List generated NuGet packages
          found_pkg=0
          for pkg in release-packages/*.nupkg release-packages/*.snupkg release-packages/*.symbols.nupkg; do
            if [ -f "$pkg" ]; then
              echo "- \`$(basename "$pkg")\`" >> RELEASE_NOTES.md
              found_pkg=1
            fi
          done
          if [ "$found_pkg" -eq 0 ]; then
            echo "- _No packages copied into release-packages/_" >> RELEASE_NOTES.md
          fi

          # Find and include changelog content if available
          CHANGELOG_CONTENT_FILE="release-artifacts/changelog-content-${LIBRARY_NAME}/changelog-${LIBRARY_NAME}.md"
          if [ -f "$CHANGELOG_CONTENT_FILE" ]; then
            echo -e "\n## ðŸ”§ Updates\n" >> RELEASE_NOTES.md
            cat "$CHANGELOG_CONTENT_FILE" >> RELEASE_NOTES.md
          else
            # Fallback: Add commit log for this release version
            PREV_TAG=$(git tag --list "${LIBRARY_NAME}-v*" --sort=-v:refname | grep -v "${LIBRARY_NAME}-v${VERSION}$" | head -1 || true)

            if [ -n "$PREV_TAG" ]; then
              echo -e "\n## ðŸ“ Commits in this release\n" >> RELEASE_NOTES.md
              git log --pretty=format:"- %s (%h) [%an]" "$PREV_TAG"..HEAD -- . | grep -i "$LIBRARY_NAME" || true >> RELEASE_NOTES.md || \
                git log --pretty=format:"- %s (%h) [%an]" "$PREV_TAG"..HEAD >> RELEASE_NOTES.md
            else
              echo -e "\n## ðŸ“ Commits in this release\n" >> RELEASE_NOTES.md
              git log --pretty=format:"- %s (%h) [%an]" -- . | grep -i "$LIBRARY_NAME" || true >> RELEASE_NOTES.md || \
                git log --pretty=format:"- %s (%h) [%an]" >> RELEASE_NOTES.md
            fi

            echo -e "\n## ðŸ”§ Updates\n" >> RELEASE_NOTES.md
            echo "This release includes updates to $LIBRARY_NAME." >> RELEASE_NOTES.md
          fi

          cat >> RELEASE_NOTES.md << EOF

          ## ðŸ“¥ Installation via GitHub Packages
          Configure your NuGet source:
          \`\`\`bash
          dotnet nuget add source --username YOUR_USERNAME --password YOUR_PAT --store-password-in-clear-text --name github "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json"
          \`\`\`
          EOF

          echo "has_packages=$(ls release-packages/*.nupkg 2>/dev/null | wc -l)" >> $GITHUB_OUTPUT

      - name: Create Git tag
        id: create-tag
        if: ${{ steps.prepare-assets.outputs.has_packages > 0 }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          LIBRARY_NAME="${{ needs.validate-release.outputs.library_name }}"
          VERSION="${{ needs.validate-release.outputs.release_version }}"

          TAG_NAME="${LIBRARY_NAME}-v${VERSION}"
          TAG_MESSAGE="Release ${LIBRARY_NAME} v${VERSION}"

          if git tag | grep -q "^${TAG_NAME}$"; then
            echo "Tag $TAG_NAME already exists, skipping tag creation"
          else
            git tag -a "$TAG_NAME" -m "$TAG_MESSAGE"
            git push origin "$TAG_NAME"
            echo "Created and pushed tag: $TAG_NAME"
          fi

          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        if: ${{ steps.prepare-assets.outputs.has_packages > 0 }}
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.create-tag.outputs.tag_name }}
          name: ${{ format('{0} v{1}', needs.validate-release.outputs.library_name, needs.validate-release.outputs.release_version) }}
          body_path: RELEASE_NOTES.md
          files: |
            release-packages/*.nupkg
            release-packages/*.snupkg
            release-packages/*.symbols.nupkg
          draft: false
          prerelease: ${{ contains(needs.validate-release.outputs.release_version, '-') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
